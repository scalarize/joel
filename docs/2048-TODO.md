## 📋 TODO：为2048 AI实现「希望驱动搜索」引擎

### 🎯 目标

在现有单步贪心AI的基础上，增加一个**前置的“希望驱动搜索”阶段**。该阶段旨在以极小计算成本，主动发现那些**即使在最坏随机性干扰下，也能导向极高收益的复杂操作序列**。若发现此类“黄金路径”，则优先执行；若未发现，则降级回原有的可靠评估。

### 🔧 核心设计

1. **两个阶段决策流**：

   text

   ```
   AI决策开始
   │
   ├── **阶段A: [希望搜索]** ──（尝试发现“黄金路径”）
   │      假设对手（随机性）总是放置最坏方块
   │      进行有限深度（如3-4步）搜索
   │      若找到评估分极高的节点，则记录路径第一步
   │      ↓
   │      找到？ → 立即执行该步
   │      未找到？ → 进入阶段B
   │
   └── **阶段B: [常规评估]** ──（保底）
           运行现有的 `aiDecideMove` 单步贪心AI。
   ```

   

2. **关键概念定义**：

   - **最坏方块**：由函数 `placeWorstTile(grid)` 定义。初级实现：在**距离当前最大数最近的空位**上放置一个 `4`。
   - **极高价值节点**：由阈值 `HOPE_THRESHOLD` 定义。可动态设定，如 `当前最大数 * 2` 时局面的评估分数，或一个固定高分（如 `1000`）。
   - **搜索深度**：建议从 `3` 开始（即AI-恶意对手交替共3轮）。

### 📝 实现步骤

1. **实现 `findWorstEmptyTilePosition(grid)`**：
   - 输入：当前网格。
   - 逻辑：找到所有空位，计算每个空位与当前最大数格子的曼哈顿距离，返回距离最近的那个空位坐标。若距离相同，可随机选或选更靠近中心的位置。
2. **实现 `placeWorstTile(grid)`**：
   - 调用上述函数得到位置 `(r, c)`。
   - 返回一个克隆的新网格，其中 `grid[r][c].value = 4`。
3. **实现递归搜索函数 `search(nodeGrid, depth)`**：
   - **基线**：若 `depth <= 0`，则评估 `nodeGrid`，分数超过 `HOPE_THRESHOLD` 则返回 `{found: true}`。
   - **递归**：
     - **AI回合**：遍历4个方向，获得 `movedGrid`。
     - **对手回合**：调用 `placeWorstTile(movedGrid)` 得到 `afterBadTile`。
     - 递归调用 `search(afterBadTile, depth - 1)`。
     - 若递归返回 `found: true`，且当前为第一层，则记录当前方向。
4. **实现主入口 `findHopefulPath(grid, depth)`**：
   - 调用 `search(grid, depth)`。
   - 若找到，返回第一步的方向；否则返回 `null`。
5. **修改主决策函数 `aiDecideMoveWithHope(grid)`**：
   - 先调用 `findHopefulPath`。
   - 若有返回，则执行该方向并记录日志（如 `✨ 发现希望路径`）。
   - 若无，则降级调用原有 `aiDecideMove`。

### ⚙️ 调参与优化点

1. **`HOPE_THRESHOLD`**：动态阈值效果可能更好，例如 `evaluateGrid(达到下一级大数的局面)`。
2. **`placeWorstTile` 策略**：这是算法的“嗅觉”，可升级为：分析当前棋盘结构，选择会**阻断关键合并通道**或**破坏大数集群**的位置。
3. **搜索深度**：深度3是平衡点，可尝试4，但需注意性能。
4. **性能**：此搜索为有限深度对抗搜索，计算量可控。若担心性能，可设置为每N步触发一次，而非每步都触发。

### ✅ 成功验证标准

- 运行时控制台能偶尔出现 `✨ 发现希望路径` 的日志。
- 触发该路径的决策，在**人为复盘**时，能看出是一系列为了达成某个精妙目标的连贯操作（例如，迂回清理障碍以合并大数）。
- AI的整体分数和最大合成数有**可观测的提升**。

### 💡 理念

此功能是典型的**机会主义优化**：用很小的计算成本，去博取发现“黄金操作序列”的小概率事件。一旦发现，收益极高；即便未发现，也有可靠保底。